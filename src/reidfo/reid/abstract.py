from abc import ABC, abstractmethod
from typing import Optional
import pandas as pd

from src.reidfo.core.validation_utils import check_axis_is_date, check_axis_is_string


# reviewed
class RegimeModel(ABC):
    def __init__(self, time_series: pd.Series, feature_matrix: pd.DataFrame, seed: Optional[int]):
        """
        Abstract base class for forecasting models.

        Stores feature matrix and labels for supervised time series forecasting.
        Verifies correct shape, naming, and index alignment.

        :param time_series: The time series
        :param feature_matrix: DataFrame of features with a DatetimeIndex and string-named columns.
        :param seed: Random seed for reproducibility.
        :raises ValueError: If index is not datetime or columns are not strings.
        """
        self.time_series = time_series.copy()
        self.feature_matrix = feature_matrix.copy()
        self.seed = seed
        self._labels: Optional[pd.Series] = None
        self._fitted = False

        check_axis_is_date(self.feature_matrix, axis=0)
        check_axis_is_date(self.time_series, axis=0)
        check_axis_is_string(self.feature_matrix, axis=1)

    @abstractmethod
    def fit(self) -> None:
        """
        Fit the model to the training data.

        :param prob: If True, returns probabilities (not implemented).
        """
        self._fitted = True

    def predict(self, feature_matrix: pd.DataFrame) -> Optional[pd.Series | pd.DataFrame]:
        """
        Predict regimes from new features. Currently, a placeholder.
        Ensures features are consistent and follow time ordering.

        :param feature_matrix: Feature matrix with same columns as training and future-dated index.
        :return: Placeholder None.
        :raises ValueError: If index/column mismatch or temporal inconsistency.
        """
        if set(feature_matrix.columns) != set(self.feature_matrix.columns):
            raise ValueError("Prediction feature matrix must have the same columns as training matrix.\n"
                             f"Feature matrix: {feature_matrix.columns}\n"
                             f"Training matrix: {self.feature_matrix.columns}\n")
        if feature_matrix.index[0] < self.feature_matrix.index[-1]:
            raise ValueError("Prediction data must start after training data (time series order).")
        return None

    def get_training_labels(self) -> Optional[pd.Series]:
        """
        Returns the regime labels generated by the model during training.

        :return: Series of training labels or None if model was not fit.
        """
        return self._labels
